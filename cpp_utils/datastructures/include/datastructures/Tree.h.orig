#ifndef TREE_H_1MKPBXLX
#define TREE_H_1MKPBXLX

#include "algorithms/alg_ext.h"
<<<<<<< HEAD
=======
#include "types/NamedType.h"
>>>>>>> develop
#include <algorithm>
#include <concepts>
#include <functional>
#include <memory>
#include <optional>
#include <queue>
#include <ranges>
#include <span>
#include <sstream>
#include <stack>
#include <utility>
#include <vector>

<<<<<<< HEAD
namespace ds {

class SourcePosition {
public:
    explicit SourcePosition(int64_t p_)
        : p{p_}
    {
    }

    operator int64_t() const { return p; }

    friend auto operator<=>(const SourcePosition&,
                            const SourcePosition&) = default;

private:
    int64_t p;
};

class DestinationPosition {
public:
    explicit DestinationPosition(int64_t p_)
        : p{p_}
    {
    }

    operator int64_t() const { return p; }

    friend auto operator<=>(const DestinationPosition&,
                            const DestinationPosition&) = default;

private:
    int64_t p;
};

class Count {
public:
    explicit Count(int64_t p_)
        : p{p_}
    {
    }

    operator int64_t() const { return p; }

    friend auto operator<=>(const Count&, const Count&) = default;

private:
    int64_t p;
};
=======
#include <limits>

namespace ds {

struct CountTag { };
using Count = types::ImplicitNamedType<int64_t, CountTag>;

struct SourcePosTag { };
using SourcePosition = types::ImplicitNamedType<int64_t, SourcePosTag>;

struct DestinationPosTag { };
using DestinationPosition =
    types::ImplicitNamedType<int64_t, DestinationPosTag>;
>>>>>>> develop

template <std::default_initializable PayloadT> class Tree {
private:
    struct Node {
        friend class Tree;

        Node() = default;

        Node(PayloadT payload_)
            : payload{payload_}
        {
        }

        auto insert(std::unique_ptr<Node> child,
<<<<<<< HEAD
                    const std::optional<DestinationPosition>& pos) -> void
=======
                    const std::optional<DestinationPosition>& position) -> void
>>>>>>> develop
        {
            child->parent = this;
            const auto num_children{static_cast<int64_t>(children.size())};
            const auto destination_pos{static_cast<int64_t>(
<<<<<<< HEAD
                pos.value_or(DestinationPosition{num_children}))};
            const auto insert_pos{std::min(num_children, destination_pos)};
            auto insert_it = children.begin() + insert_pos;
            children.insert(insert_it, std::move(child));
            fix_right_pointers_after_insertion(insert_pos, 1);
        }

        template <typename InputIt>
        auto insert(DestinationPosition pos, InputIt first, InputIt last)
=======
                position.value_or(DestinationPosition{num_children}))};
            const auto insert_pos{std::min(num_children, destination_pos)};
            auto insert_it = children.begin() + insert_pos;
            auto first = children.insert(insert_it, std::move(child));
            rebuild_position_indexes(first - children.begin());
        }

        template <typename InputIt>
        auto insert(DestinationPosition position, InputIt first, InputIt last)
>>>>>>> develop
            -> void
        {
            if (first == last) {
                return;
            }
            const auto insert_pos = std::min(
                DestinationPosition{static_cast<int64_t>(children.size())},
<<<<<<< HEAD
                pos);
            auto insert_it = children.begin() + insert_pos;

            for (auto it = first; it != last; ++it) {
                it->get()->parent = this;
                auto next = std::next(it);
                it->get()->right = next == last ? nullptr : next->get();
            }

            children.insert(insert_it, first, last);
            fix_right_pointers_after_insertion(pos, std::distance(first, last));
=======
                position);
            auto insert_it = children.begin() + insert_pos;
            auto it = children.insert(insert_it, first, last);
            rebuild_parent_pointers();
            rebuild_position_indexes(it - children.begin());
>>>>>>> develop
        }

        auto take(Node* node) -> std::unique_ptr<Node>
        {
            auto it = std::ranges::find_if(
                children, [&](auto& p) { return p.get() == node; });
<<<<<<< HEAD
            if (it != children.begin()) {
                std::prev(it)->get()->right = std::next(it)->get();
            }
            auto subroot = std::move(*it);
            children.erase(it);
=======
            auto subroot = std::move(*it);
            auto first = children.erase(it);
            rebuild_position_indexes(first - children.begin());
>>>>>>> develop
            return subroot;
        }

        auto move(SourcePosition source,
                  Count count,
                  DestinationPosition destination) -> void
        {
<<<<<<< HEAD
            fix_right_pointers_before_moving(source, count);
=======
>>>>>>> develop
            alg::slide(children.begin() + source,
                       children.begin() + source + count,
                       children.begin() + destination);

<<<<<<< HEAD
            // TODO replace with fine-tuned pointer designation
            for (size_t i = 1; i < children.size(); ++i) {
                children[i - 1]->right = children[i].get();
            }
            children.back()->right = nullptr;
            fix_right_pointers_after_insertion(destination, count);
=======
            rebuild_position_indexes(0);
>>>>>>> develop
        }

        auto move(SourcePosition source_pos,
                  Count count,
                  Node* destination,
                  DestinationPosition destination_pos)
        {
            if (destination == this) {
                move(source_pos, count, destination_pos);
                return;
            }
<<<<<<< HEAD
            fix_right_pointers_before_moving(source_pos, count);
=======
>>>>>>> develop
            auto [first, last] =
                alg::slide(children.begin() + source_pos,
                           children.begin() + source_pos + count,
                           children.end());
            destination->insert(destination_pos,
                                std::make_move_iterator(first),
                                std::make_move_iterator(last));
            children.erase(first, last);
<<<<<<< HEAD
=======
            rebuild_position_indexes(source_pos);
>>>>>>> develop
        }

    private:
        Node* parent{nullptr};
<<<<<<< HEAD
        Node* right{nullptr};
        std::vector<std::unique_ptr<Node>> children;
        PayloadT payload{};

        auto fix_right_pointers_after_insertion(int64_t insert_pos,
                                                int64_t count) -> void
        {
            auto first_inserted = children.begin() + insert_pos;
            auto first_of_old_values = first_inserted + count;

            // left -> [values] -> ?
            if (insert_pos != 0) {
                std::prev(first_inserted)->get()->right = first_inserted->get();
            }
            // ? -> [values] -> right
            if (static_cast<size_t>(insert_pos + count) < children.size()) {
                std::prev(first_of_old_values)->get()->right =
                    first_of_old_values->get();
            }
            // ? -> [values]
            else {
                std::prev(children.end())->get()->right = nullptr;
            }
        }

        auto fix_right_pointers_before_moving(int64_t start_pos, int64_t count)
            -> void
        {
            if (start_pos == 0 or children.empty()) {
                return;
            }
            auto start_it = children.begin() + start_pos;
            Node* next_right_ptr =
                static_cast<size_t>(start_pos + count) < children.size()
                    ? (start_it + count)->get()
                    : nullptr;
            std::prev(start_it)->get()->right = next_right_ptr;
=======
        int64_t pos{0};
        std::vector<std::unique_ptr<Node>> children;
        PayloadT payload{};

        auto rebuild_position_indexes(int64_t first)
        {
            std::for_each(
                children.begin() + first,
                children.end(),
                [pos = first](auto& child) mutable { child->pos = pos++; });
        }

        auto rebuild_parent_pointers()
        {
            std::for_each(children.begin(),
                          children.end(),
                          [this](auto& child) { child->parent = this; });
>>>>>>> develop
        }
    };

public:
    template <typename TransformFunc>
    using TransformResultT = std::remove_cvref_t<
        std::invoke_result_t<TransformFunc, const PayloadT&>>;

    template <typename v_type, typename node_type> class DfsIterator {
    public:
        using iterator_category = std::forward_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using element_type = v_type;

        friend class DfsIterator<const v_type, const node_type>;
        friend class Tree;

        DfsIterator() = default;

        explicit DfsIterator(node_type* p_)
            : ptr{p_}
        {
        }

        DfsIterator(const DfsIterator&) = default;

        // Conversion constructor that permits convertion from iterator to
        // const_iterator but is disabled to prevent convertion from
        // const_iterator to iterator
        template <typename n_type, typename nv_type>
            requires(!std::is_const_v<n_type> && std::is_const_v<node_type> &&
                     std::is_same_v<std::remove_const_t<node_type>, n_type>)
        DfsIterator(const DfsIterator<nv_type, n_type>& rhs)
            : ptr{rhs.ptr}
            , prev{rhs.prev}
        {
        }

        auto operator*() const -> element_type& { return ptr->payload; }

        auto operator->() -> element_type* { return &ptr; }

        auto operator++() -> DfsIterator&
        {
<<<<<<< HEAD
            node_type* unvisited_child = nullptr;

            if (ptr->parent != prev) {
                // We came up from one of the children - grab it's right
                // neighbor
                unvisited_child = prev->right;
            }
            else {
                // We came down from parent - take first child if there are
                // children
                unvisited_child = ptr->children.empty()
                                      ? nullptr
                                      : ptr->children.front().get();
            }

            prev = ptr;
            ptr = unvisited_child != nullptr ? unvisited_child : ptr->parent;

            // ptr now points to previously visited node, run another
            // iteration
=======
            auto* tmp = ptr;
            ptr = bottom_reached() ? ptr->parent : next_node();
            prev = tmp;

            // Node has been visited before, skip it
>>>>>>> develop
            if (ptr and prev != ptr->parent) {
                this->operator++(1);
            }

            return *this;
        }

        auto operator++(int) -> DfsIterator
        {
            auto tmp = *this;
            ++(*this);
            return tmp;
        }

        friend auto operator==(const DfsIterator& lhs, const DfsIterator& rhs)
            -> bool
        {
            return lhs.ptr == rhs.ptr;
        }

        friend auto operator!=(const DfsIterator& lhs, const DfsIterator& rhs)
            -> bool
        {
            return not(lhs.ptr == rhs.ptr);
        }

    private:
        node_type* ptr{nullptr};
        node_type* prev{nullptr};
<<<<<<< HEAD
=======
        typename std::vector<std::unique_ptr<Node>>::iterator p_it;

        auto bottom_reached() const -> bool
        {
            // ptr points to leaf without siblings to the right
            return ptr->children.empty() or
                   (prev != ptr->parent and
                    (prev->pos + 1 >= std::ssize(ptr->children)));
        }

        auto next_node() const -> node_type*
        {
            // Pick first child if came from parent or next child if came from
            // child.
            const auto offset =
                static_cast<size_t>(prev == ptr->parent ? 0 : prev->pos + 1);
            return ptr->children[offset].get();
        }
>>>>>>> develop
    };

    using value_type = PayloadT;
    using iterator = DfsIterator<value_type, Node>;
    using const_iterator = DfsIterator<const value_type, const Node>;

    Tree() = default;

    ~Tree() { release_subtree(std::move(root)); }

    Tree(const Tree& other)
    {
        if (this == &other) {
            return;
        }
        *this = other.transform(std::identity{});
    }

    Tree(Tree&& other) = default;

    auto operator=(Tree&& other) -> Tree& = default;

    auto operator=(const Tree& other) -> Tree&
    {
        if (this == &other) {
            return *this;
        }
        root = std::move(other.transform(std::identity{}).root);
        return *this;
    }

    auto parent(const_iterator it) const -> const_iterator
    {
        if (it == cend() or it.ptr->parent == root.get()) {
            return cend();
        }
        return const_iterator{it.ptr->parent};
    }

<<<<<<< HEAD
    auto parent(iterator it) -> iterator {
=======
    auto parent(iterator it) -> iterator
    {
>>>>>>> develop
        if (it == end() or it.ptr->parent == root.get()) {
            return end();
        }
        return iterator{it.ptr->parent};
    }

<<<<<<< HEAD
    auto children(iterator it) {
        auto* true_ptr = it == end() ? root.get() : it.ptr;
        return std::views::transform(true_ptr->children, [](auto& node) {
            return node->payload;
        });
    }

    auto children(const_iterator it) const {
        auto* true_ptr = it == cend() ? root.get() : it.ptr;
        return std::views::transform(true_ptr->children, [](const auto& node) {
            return node->payload;
        });
=======
    auto children(iterator it)
    {
        auto* true_ptr = it == end() ? root.get() : it.ptr;
        return std::views::transform(true_ptr->children,
                                     [](auto& node) { return node->payload; });
    }

    auto children(const_iterator it) const
    {
        auto* true_ptr = it == cend() ? root.get() : it.ptr;
        return std::views::transform(
            true_ptr->children, [](const auto& node) { return node->payload; });
>>>>>>> develop
    }

    auto insert(iterator parent,
                PayloadT payload,
                const std::optional<DestinationPosition>& pos = std::nullopt)
        -> iterator
    {
        auto* true_parent{parent == end() ? root.get() : parent.ptr};
        auto child = std::make_unique<Node>(std::move(payload));
        auto* child_ptr = child.get();
        true_parent->insert(std::move(child), pos);
        return iterator{child_ptr};
    }

    auto take_subtree(iterator subtree_root) -> Tree
    {
        auto* parent = subtree_root.ptr->parent;
        Tree subtree;
        subtree.root->insert(parent->take(subtree_root.ptr), std::nullopt);
        return subtree;
    }

    auto move_nodes(iterator source_parent,
                    SourcePosition source_pos,
                    Count count,
                    iterator destination_parent,
                    DestinationPosition destination_pos) -> void
    {
        auto* source_parent_ptr{source_parent == end() ? root.get()
                                                       : source_parent.ptr};
        auto* destination_parent_ptr{
            destination_parent == end() ? root.get() : destination_parent.ptr};

        source_parent_ptr->move(
            source_pos, count, destination_parent_ptr, destination_pos);
    }

    auto erase(iterator subtree_root) -> void
    {
        release_subtree(take_subtree(subtree_root).root);
    }

<<<<<<< HEAD
=======
    auto position_in_children(const_iterator it) const -> int64_t
    {
        return it == end() ? 0 : it.ptr->pos;
    }

>>>>>>> develop
    template <typename Func>
    auto transform(Func func) const -> Tree<TransformResultT<Func>>
    {
        using Y = TransformResultT<Func>;
        Tree<Y> mapped;
        std::queue<std::pair<const Node*, typename Tree<Y>::iterator>> frontier;
        frontier.push({root.get(), mapped.end()});

        while (not frontier.empty()) {
            auto entry = frontier.front();
            auto* current = entry.first;
            auto mapped_it = entry.second;
            frontier.pop();

            for (const auto& child : current->children) {
                auto it = mapped.insert(mapped_it, func(child->payload));
                frontier.push({child.get(), it});
            }
        }

        return mapped;
    }

    friend auto operator==(const Tree& lhs, const Tree& rhs) -> bool
    {
        return std::ranges::equal(lhs, rhs);
    }

    auto flatten() const -> std::vector<std::optional<PayloadT>>
    {
        std::queue<const Node*> frontier;
        frontier.push(root.get());

        std::vector<std::optional<PayloadT>> flattened{std::nullopt,
                                                       std::nullopt};

        while (not frontier.empty()) {
            const auto* current = frontier.front();
            frontier.pop();

            for (const auto& child : current->children) {
                flattened.push_back(child->payload);
                frontier.push(child.get());
            }
            flattened.push_back(std::nullopt);
        }

        return flattened;
    }

    static auto unflatten(std::span<const std::optional<PayloadT>> flat) -> Tree
    {
        Tree<PayloadT> restored;
        std::queue<iterator> frontier;
        frontier.push(restored.begin());

        for (size_t i{2}; not frontier.empty(); ++i) {
            auto parent_it = frontier.front();
            frontier.pop();
            for (; flat[i]; ++i) {
                auto it =
                    restored.insert(parent_it, std::move(flat[i].value()));
                frontier.push(it);
            }
        }

        return restored;
    }

<<<<<<< HEAD
    // auto parent(iterator subtree_root) -> iterator
    // {
    //     return iterator{subtree_root.ptr->parent};
    // }
    //
    // auto parent(const_iterator subtree_root) const -> const_iterator
    // {
    //     return const_iterator{subtree_root.ptr->parent};
    // }

=======
>>>>>>> develop
    auto begin() -> iterator { return ++iterator(root.get()); }

    auto end() -> iterator { return iterator(nullptr); }

    auto begin() const -> const_iterator
    {
        return ++const_iterator(root.get());
    }

    auto end() const -> const_iterator { return const_iterator(nullptr); }

    auto cbegin() const -> const_iterator
    {
        return ++const_iterator(root.get());
    }

    auto cend() const -> const_iterator { return const_iterator(nullptr); }

    auto to_string() const -> std::string
    {
        std::stack<std::pair<int, Node*>> frontier;
        for (auto& child : std::views::reverse(root->children)) {
            frontier.push({0, child.get()});
        }

        std::stringstream ss;

        while (not frontier.empty()) {
            auto [level, current] = frontier.top();
            frontier.pop();

<<<<<<< HEAD
            for (int i = 0; i < level; ++i) {
                ss << "   ";
            }
            if (current) {
                ss << current->payload << '\n';
=======
            if (current) {
                ss << std::string(static_cast<size_t>(level * 3), ' ')
                   << current->payload << '\n';
>>>>>>> develop
            }

            for (auto& child : std::views::reverse(current->children)) {
                frontier.push({level + 1, child.get()});
            }
        }

        return ss.str();
    }

private:
    std::unique_ptr<Node> root{std::make_unique<Node>()};

    auto release_subtree(std::unique_ptr<Node> subtree_root) -> void
    {
        if (not subtree_root) {
            return;
        }

        while (not subtree_root->children.empty()) {
            auto leaves = &subtree_root->children;
            while (not leaves->back()->children.empty()) {
                leaves = &leaves->back()->children;
            }
            leaves->pop_back();
        }
    }
};

static_assert(std::is_copy_constructible_v<Tree<int>::iterator>);
static_assert(std::is_copy_constructible_v<Tree<int>::const_iterator>);

// Iterator convertions
static_assert(std::is_convertible_v<Tree<int>::iterator, Tree<int>::iterator>);
static_assert(std::is_convertible_v<Tree<int>::const_iterator,
                                    Tree<int>::const_iterator>);
static_assert(
    std::is_convertible_v<Tree<int>::iterator, Tree<int>::const_iterator>);
static_assert(
    not std::is_convertible_v<Tree<int>::const_iterator, Tree<int>::iterator>);

// Prevents convertion from iterators from other types
static_assert(
    not std::is_convertible_v<Tree<double>::iterator, Tree<int>::iterator>);
static_assert(not std::is_convertible_v<Tree<double>::const_iterator,
                                        Tree<int>::const_iterator>);

static_assert(std::is_trivially_copy_constructible_v<Tree<int>::iterator>);
static_assert(
    std::is_trivially_copy_constructible_v<Tree<int>::const_iterator>);

static_assert(std::forward_iterator<Tree<int>::iterator>);
static_assert(std::forward_iterator<Tree<int>::const_iterator>);

} // namespace ds

#endif /* end of include guard: TREE_H_1MKPBXLX */
